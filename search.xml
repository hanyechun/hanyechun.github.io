<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android面试题</title>
    <url>/2020/03/16/Android%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="Java部分"><a href="#Java部分" class="headerlink" title="Java部分"></a>Java部分</h4><h5 id="1-GC是什么-为什么要有GC"><a href="#1-GC是什么-为什么要有GC" class="headerlink" title="1.GC是什么? 为什么要有GC?"></a>1.GC是什么? 为什么要有GC?</h5><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p>
<a id="more"></a>

<h5 id="2-XML包括哪些解析技术，区别是什么？"><a href="#2-XML包括哪些解析技术，区别是什么？" class="headerlink" title="2.XML包括哪些解析技术，区别是什么？"></a>2.XML包括哪些解析技术，区别是什么？</h5><p>DOM和SAX<br>DOM将文档解析成一颗文档树，可在节点上进行遍历、增加、修改和删除。一次性读入内存，对内存消耗大。<br>SAX至上而下解析文档，以事件进行驱动。不会一次性读入内存，对内存消耗小，不能任意读取节点，并且不能对节点进行增加、修改和删除。</p>
<h5 id="3-switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#3-switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="3.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a>3.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</h5><p>switch能作用在byte、char、short和int上，JDK1.7后可以作用在String上。</p>
<h5 id="4-”-”和equals方法究竟有什么区别？"><a href="#4-”-”和equals方法究竟有什么区别？" class="headerlink" title="4.”==”和equals方法究竟有什么区别？"></a>4.”==”和equals方法究竟有什么区别？</h5><p>==和equals都可以比较地址。==是运算符，equals是方法，方法可以通过重写改变其行为，如String的equals就是比较字符串内容。</p>
<h5 id="5-构造方法能否被重写和重载？"><a href="#5-构造方法能否被重写和重载？" class="headerlink" title="5.构造方法能否被重写和重载？"></a>5.构造方法能否被重写和重载？</h5><p>构造方法不能被重写但是能被重载。</p>
<h5 id="6-面向对象的特征有哪些？"><a href="#6-面向对象的特征有哪些？" class="headerlink" title="6.面向对象的特征有哪些？"></a>6.面向对象的特征有哪些？</h5><p>封装、继承、多态和抽象。</p>
<h5 id="7-抽象类和接口的区别？"><a href="#7-抽象类和接口的区别？" class="headerlink" title="7.抽象类和接口的区别？"></a>7.抽象类和接口的区别？</h5><p>1).抽象类是abstract class修饰，接口是interface修饰。<br>2).抽象类可以有任意类型的属性，接口只能有静态常量修饰的属性。<br>3).抽象类可以有普通方法和抽象法方法，接口的方法都是抽象方法。<br>4).抽象类和接口都不能实例化，但是抽象类有构造方法，接口没有构造方法。<br>5).抽象类只能单根继承，接口可以多重实现。</p>
<h5 id="8-内部类可以引用它的包含类的成员吗？有没有什么限制？"><a href="#8-内部类可以引用它的包含类的成员吗？有没有什么限制？" class="headerlink" title="8.内部类可以引用它的包含类的成员吗？有没有什么限制？"></a>8.内部类可以引用它的包含类的成员吗？有没有什么限制？</h5><p>可以引用。如果需要指定当前类时要用外部类.this来引用。如果引用局部变量，需要将局部变量指定为final。</p>
<h5 id="9-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？"><a href="#9-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？" class="headerlink" title="9.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？"></a>9.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</h5><p>2个对象。”xyz”创建在字符串常量池中，new String()创建在堆中。</p>
<h5 id="10-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#10-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="10.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>10.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?</h5><p>会在return前执行。</p>
<h5 id="11-Integer与int的区别"><a href="#11-Integer与int的区别" class="headerlink" title="11.Integer与int的区别"></a>11.Integer与int的区别</h5><p>Integer为包装类，int是基本数据类型。包装类拥有方法和属性，基本数据类型不具备。包装类可以通过intValue来转换成基本数据类型，也可以通过new Integer()将基本数据类型转换为包装类。在JDK1.5后，包装类和基本数据类型可以实现自动转换。</p>
<h5 id="12-sleep-和wait-有什么区别"><a href="#12-sleep-和wait-有什么区别" class="headerlink" title="12.sleep()和wait()有什么区别?"></a>12.sleep()和wait()有什么区别?</h5><p>sleep是Thread类的方法，wait是Object类的方法。<br>sleep是自动唤醒，wait需要其他线程来唤醒。<br>sleep不会释放同步锁，wait会释放同步锁。<br>sleep可以用在任意方法中，wait只能用在同步方法或同步块中。<br>Sleep（）不会释放对象锁到时自动恢复， wait（）会释放对象锁 进入等待此对象的等待锁定池 发出notify（）方法后 才进入等待锁定池准备对象锁的获 取进入运行状态</p>
<h5 id="13-同步和异步有何异同，在什么情况下分别使用他们？"><a href="#13-同步和异步有何异同，在什么情况下分别使用他们？" class="headerlink" title="13.同步和异步有何异同，在什么情况下分别使用他们？"></a>13.同步和异步有何异同，在什么情况下分别使用他们？</h5><p>同步指同一时间只能一个线程执行该方法，其他线程需要等待。异步指多个线程可以同时执行某个方法，并共享同一资源。<br>同步可以让访问的资源具有安全性，因为同一时间只能一个线程对其进行访问。但是效率不高。<br>异步对访问的资源会造成不稳定性，比如多个线程同时访问一个资源，一个在修改、一个在删除、一个在读取，这样可能会造成资源的混乱。但是由于同时运行， 执行效率得到提高。</p>
<h5 id="14-启动一个线程是用run-还是start"><a href="#14-启动一个线程是用run-还是start" class="headerlink" title="14.启动一个线程是用run()还是start()?"></a>14.启动一个线程是用run()还是start()?</h5><p>start()方法启动线程，run方法是线程执行的主方法。</p>
<h5 id="15-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#15-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="15.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a>15.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</h5><p>java中有三种流，分别是字节流（InputStream、OutputStream）、字符流（Reader、Writer）、对象流（ObjectInputStream、 ObjectOutputStream）。</p>
<h5 id="16-字节流与字符流的区别？"><a href="#16-字节流与字符流的区别？" class="headerlink" title="16.字节流与字符流的区别？"></a>16.字节流与字符流的区别？</h5><p>字节流用于读取或写出二进制数据，比如图片、影像等数据。<br>字符流用于读取或写出字符数据，比如传输字符串。<br>所有的数据都可以通过字节流来进行处理，不过如果是字符数据，用字节流还需要进行转换后传输，如果使用字符流可以方便数据的转换。</p>
<h5 id="17-error和exception有什么区别"><a href="#17-error和exception有什么区别" class="headerlink" title="17.error和exception有什么区别?"></a>17.error和exception有什么区别?</h5><p>error是系统错误，代码不能处理的错误，比如内存溢出、堆栈溢出等。<br>exception是程序异常，可以通过代码try-catch进行处理，比如空指针异常，数组越界等。</p>
<h5 id="18-谈谈final-finally-finalize的区别？"><a href="#18-谈谈final-finally-finalize的区别？" class="headerlink" title="18.谈谈final,finally,finalize的区别？"></a>18.谈谈final,finally,finalize的区别？</h5><p>final是修饰符，可以修饰类（不能被继承）、属性（常量）、和方法（不能被重写）。<br>finally是异常处理块中的代码块，表示无论如何都会执行的代码块。<br>finalize是Object类的方法，该方法在对象被垃圾回收之前执行的方法。</p>
<h5 id="19-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#19-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="19.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>19.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h5><p>如果其他方法没有加synchronized的话是可以进入的。</p>
<h5 id="20-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#20-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="20.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>20.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h5><p>java中只有值传递，如果传递的对象，实际也是传递该对象的地址。</p>
<h5 id="21-作用域public-private-protected-以及不写时的区别"><a href="#21-作用域public-private-protected-以及不写时的区别" class="headerlink" title="21.作用域public,private,protected,以及不写时的区别"></a>21.作用域public,private,protected,以及不写时的区别</h5><p>public公共修饰符，表示任意类都可以访问。<br>protected为受保护的修饰符，表示同类、同包以及不同包但是父子关系的是可以访问。<br>不写表示默认修饰符，或者称为package修饰符，该修饰符表示只有同类或同包下的类可以访问，出了这个包就不能访问了。<br>private为私有修饰符，表示只有同类中可以访问，出了这个类就不能访问了。</p>
<h5 id="22-用最有效率的方法算出2乘以8等於几-2《-3"><a href="#22-用最有效率的方法算出2乘以8等於几-2《-3" class="headerlink" title="22.用最有效率的方法算出2乘以8等於几 2《 3"></a>22.用最有效率的方法算出2乘以8等於几 2《 3</h5><p>将2的二进制向左移3位。java中用&lt;&lt;来移位。</p>
<h5 id="23-heap和stack有什么区别。"><a href="#23-heap和stack有什么区别。" class="headerlink" title="23.heap和stack有什么区别。"></a>23.heap和stack有什么区别。</h5><p>heap表示堆，stack表示栈。堆中放对象，栈中放引用变量。<br>堆空间是一个无序的空间，栈是先进后出的结构。</p>
<h5 id="24-运行时异常与一般异常有何异"><a href="#24-运行时异常与一般异常有何异" class="headerlink" title="24.运行时异常与一般异常有何异"></a>24.运行时异常与一般异常有何异</h5><p>运行时异常是指继承于RuntimeException的异常，这些异常在编译时可以不进行处理，当运行时如果出现问题才会抛出。如NullPointException、 ArrayIndexOutOfBoundsException<br>一般异常也称为编译时异常，这些异常是继承Exception但又不属于RuntimeException的子类，如果程序中出现这些异常，在编译时必须进行捕获或抛出，否 则编译无法通过。如IOException、FileNotFoundException</p>
<h5 id="25-垃圾回收的优点和原理。并考虑2种回收机制"><a href="#25-垃圾回收的优点和原理。并考虑2种回收机制" class="headerlink" title="25.垃圾回收的优点和原理。并考虑2种回收机制"></a>25.垃圾回收的优点和原理。并考虑2种回收机制</h5><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存 管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用 的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能 实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p>
<h5 id="26-描述一下JVM加载class文件的原理机制"><a href="#26-描述一下JVM加载class文件的原理机制" class="headerlink" title="26.描述一下JVM加载class文件的原理机制?"></a>26.描述一下JVM加载class文件的原理机制?</h5><p>JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<h5 id="27-是否可以从一个static方法内部发出对非static方法的调用？"><a href="#27-是否可以从一个static方法内部发出对非static方法的调用？" class="headerlink" title="27.是否可以从一个static方法内部发出对非static方法的调用？"></a>27.是否可以从一个static方法内部发出对非static方法的调用？</h5><p>不能，除非先创建非static方法所在类的对象。</p>
<h5 id="28-什么是java序列化，如何实现java序列化？"><a href="#28-什么是java序列化，如何实现java序列化？" class="headerlink" title="28.什么是java序列化，如何实现java序列化？"></a>28.什么是java序列化，如何实现java序列化？</h5><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序 列化是为了解决在对对象流进行读写操作时所引发的问题。<br>序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化 的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的 writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
<h5 id="29-Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以implements-实现-interface-接口-？"><a href="#29-Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以implements-实现-interface-接口-？" class="headerlink" title="29.Anonymous Inner Class(匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)？"></a>29.Anonymous Inner Class(匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)？</h5><p>匿名内部类可以继承类或实现接口，但不是显示的使用extends或implements来继承或实现。</p>
<h5 id="30-ArrayList和Vector的区别-HashMap和Hashtable的区别？"><a href="#30-ArrayList和Vector的区别-HashMap和Hashtable的区别？" class="headerlink" title="30.ArrayList和Vector的区别,HashMap和Hashtable的区别？"></a>30.ArrayList和Vector的区别,HashMap和Hashtable的区别？</h5><p>ArrayList是JDK1.2的集合类并且线程不安全，Vector是1.0的集合类并且线程安全，二者用法类似。<br>HashMap线程不安全且能放空键或空值，Hashtable线程安全且不能放空键或空值。</p>
<h5 id="31-String-和StringBuffer有什么差别？在什么情况下使用它们？"><a href="#31-String-和StringBuffer有什么差别？在什么情况下使用它们？" class="headerlink" title="31.String 和StringBuffer有什么差别？在什么情况下使用它们？"></a>31.String 和StringBuffer有什么差别？在什么情况下使用它们？</h5><p>String字符串的基本类，该字符串是不可变的。StringBuffer是利用堆来存储字符串，并且可以对字符串的内容进行改变。</p>
<h5 id="32-new一个类对象和使用类名创建一个对象有什么区别？二者使用时应该注意什么？"><a href="#32-new一个类对象和使用类名创建一个对象有什么区别？二者使用时应该注意什么？" class="headerlink" title="32.new一个类对象和使用类名创建一个对象有什么区别？二者使用时应该注意什么？"></a>32.new一个类对象和使用类名创建一个对象有什么区别？二者使用时应该注意什么？</h5><p>new对象是最常见的创建对象的方式，利用类模板是通过反射来创建对象。虽然new对象时在底层也会通过类模板来创建对象，但是new对象的效率要比直接通过类 模板创建对象的方式要高。<br>但是使用类模板的方式可以让程序的灵活性提高。</p>
<h5 id="33-LinkedList和ArrayList的区别？"><a href="#33-LinkedList和ArrayList的区别？" class="headerlink" title="33.LinkedList和ArrayList的区别？"></a>33.LinkedList和ArrayList的区别？</h5><p>1）LinkedList是链表结构的集合，ArrayList数组结构的集合。<br>2）LinkedList在中间或前面增加或删除数据时效率比ArrayList高。<br>3）LinkedList在最后添加或删除数据时效率比ArrayList低。<br>4）遍历数据时ArrayList效率高于LinkedList。</p>
<h5 id="34-介绍JAVA开发中常用的Collection-FrameWork（集合框架）"><a href="#34-介绍JAVA开发中常用的Collection-FrameWork（集合框架）" class="headerlink" title="34.介绍JAVA开发中常用的Collection FrameWork（集合框架）?"></a>34.介绍JAVA开发中常用的Collection FrameWork（集合框架）?</h5><p>Java中集合框架分为Collection和Map接口，Collection接口下的集合每个元素都由一个值组成，Map接口下的集合类每个元素都是由键值对组成。<br>Collection接口下面有List和Set接口，List接口下常见的类有ArrayList、LinkedList、Vector。它们中的元素可以重复，并且是有序的。Set接口下常 见的类有HashSet、TreeSet。它们中的元素不能重复，并且是无序的。</p>
<h5 id="35-在异常当中-throw和throws-有什么区别和联系？"><a href="#35-在异常当中-throw和throws-有什么区别和联系？" class="headerlink" title="35.在异常当中 throw和throws 有什么区别和联系？"></a>35.在异常当中 throw和throws 有什么区别和联系？</h5><p>throw是在代码中抛出一个异常，后面跟的是异常对象，虚拟机运行到这里时会立即引发一个异常。<br>throws是写在方法声明上的，表示声明该方法可能会抛出异常，后面跟的是异常类型。调用该方法的时候可以选择处理它或继续往外抛。</p>
<h5 id="36-重载和重写的区别"><a href="#36-重载和重写的区别" class="headerlink" title="36.重载和重写的区别"></a>36.重载和重写的区别</h5><p>重载是指在一个类中，两个或两个以上的方法具有相同方法名和不同参数列表，则表示这些方法为重载方法。<br>重写是指在父类和子类中，子类的方法和父类的方法具有相同方法名、相同参数列表、相同返回类型、子类的访问修饰符范围不小于父类的访问修饰符范围，异常 的类型和个数不大于或多于父类的异常类型和个数，则表示该方法为重写方法。换句话说重载方法是区分同一个类中相同方法名的方法，重写方法是找到父类相同 方法名的方法并重新改变方法的行为。</p>
<h5 id="37-Java中try-catch-finally的执行顺序"><a href="#37-Java中try-catch-finally的执行顺序" class="headerlink" title="37.Java中try catch finally的执行顺序"></a>37.Java中try catch finally的执行顺序</h5><p>先执行try中代码发生异常执行catch中代码，最后一定会执行finally中代码</p>
<h5 id="38-内存泄露的原因："><a href="#38-内存泄露的原因：" class="headerlink" title="38.内存泄露的原因："></a>38.内存泄露的原因：</h5><ul>
<li>资源对象没关闭。<br>如Cursor、File等资源。他们会在finalize中关闭，但这样效率太低。容易造成内存泄露。<br>SQLiteCursor，当数据量大的时候容易泄露</li>
<li>使用Adapter时，没有使用系统缓存的converView。</li>
<li>即时调用recycle（）释放不再使用的Bitmap。<br>适当降低Bitmap的采样率，如：<br>BitmapFactory.Options options = newBitmapFactory.Options();<br>options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一<br>Bitmap bitmap =BitmapFactory.decodeStream(cr.openInputStream(uri), null, options); preview.setImageBitmap(bitmap);</li>
<li>使用application的context来替代activity相关的context。<br>尽量避免activity的context在自己的范围外被使用，这样会导致activity无法释放。</li>
<li>注册没取消造成内存泄露<br>如：广播<br>集合中的对象没清理造成的内存泄露我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会 越来越大。如果这个集合是static的话，那情况就更严重了。</li>
<li>Handler应该申明为静态对象， 并在其内部类中保存一个对外部类的弱引用。如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class MyHandler extends Handler</span><br><span class="line">&#123;</span><br><span class="line">    WeakReference&lt;Activity &gt; mActivityReference;</span><br><span class="line">    MyHandler(Activity activity)</span><br><span class="line">    &#123; </span><br><span class="line">      mActivityReference= new WeakReference&lt;Activity&gt;(activity);</span><br><span class="line">    &#125;   </span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg)</span><br><span class="line">    &#123;</span><br><span class="line">        final Activity activity = mActivityReference.get();</span><br><span class="line">        if (activity != null)</span><br><span class="line">        &#123;</span><br><span class="line">            mImageView.setImageBitmap(mBitmap);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="39-Iterator和Enumeration的不同"><a href="#39-Iterator和Enumeration的不同" class="headerlink" title="39.Iterator和Enumeration的不同"></a>39.Iterator和Enumeration的不同</h5><ul>
<li>函数接口不同<br>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。 Iterator只有3个函数接口。Iterator除了能读 取集合的数据之外，也能数据进行删除操作。</li>
<li>Iterator支持fail-fast机制，而Enumeration不支持。 Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类 都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现 Enumeration时，添加了同步。而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。<br>Iterator是支持fail-fast 机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>ail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线 程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异 常，产生fail-fast事件。</li>
</ul>
<h5 id="40-接口的注意点"><a href="#40-接口的注意点" class="headerlink" title="40.接口的注意点"></a>40.接口的注意点</h5><ul>
<li>接口中的字段全部默认为 public static类型。</li>
<li>接口中的方法全部默认为 public类型。</li>
<li>接口中可以申明内部类，而默认为public static，正因为是static，只是命名空间属于接口，代码逻辑不属于接口。所以不违法接口定义。</li>
<li>接口本身可以申明为public或者缺省。</li>
<li>抽象类继承自某接口。如果在抽象类中实现了父类（接口）中的方法，在其子类可以不用实现，否则在子类必须实现。</li>
</ul>
<h5 id="41-final方法"><a href="#41-final方法" class="headerlink" title="41.final方法"></a>41.final方法</h5><p>将方法声明为final那有两个原因，第一就是说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。第二就是允许编译器将所有对此方法的调用转化为inline调用的机制，它会使你在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如保存断点，压栈等，这样可能会使你的程序效率有所提高，然而当你的方法主体非常庞大时，或你在多处调用此方法，那么你的调用主体代码便会迅速膨胀，可能反而会影响效率，所以你要慎用final进行方法定义。</p>
<h4 id="ANDROID部分"><a href="#ANDROID部分" class="headerlink" title="ANDROID部分"></a>ANDROID部分</h4><h5 id="1-activity、Service、BroadcastReceiver的作用（android）"><a href="#1-activity、Service、BroadcastReceiver的作用（android）" class="headerlink" title="1.activity、Service、BroadcastReceiver的作用（android）"></a>1.activity、Service、BroadcastReceiver的作用（android）</h5><p>Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑<br>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的指令，定义好需要接受的Intent提供同步和异步的接口<br>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型</p>
<h5 id="2-描述一个完整的Android-activity-lifecycle"><a href="#2-描述一个完整的Android-activity-lifecycle" class="headerlink" title="2.描述一个完整的Android activity lifecycle"></a>2.描述一个完整的Android activity lifecycle</h5><p>activity的生命周期方法有：onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；</p>
<h5 id="3-显式intent和隐式intent的区别是什么（android）"><a href="#3-显式intent和隐式intent的区别是什么（android）" class="headerlink" title="3.显式intent和隐式intent的区别是什么（android）"></a>3.显式intent和隐式intent的区别是什么（android）</h5><p>Intent定义：Intent是一种在不同组件之间传递的请求消息，是应用程序发出的请求和意图。作为一个完整的消息传递机制，Intent不仅需要发送端，还需要接收端。<br>显式Intent定义：对于明确指出了目标组件名称的Intent，我们称之为显式Intent。<br>隐式Intent定义：对于没有明确指出目标组件名称的Intent，则称之为隐式Intent。<br>说明：Android系统使用IntentFilter 来寻找与隐式Intent相关的对象。</p>
<h5 id="4-Android中线程同步的方法"><a href="#4-Android中线程同步的方法" class="headerlink" title="4.Android中线程同步的方法"></a>4.Android中线程同步的方法</h5><p>线程同步的方法可以采用同步方法和同步块。</p>
<h5 id="5-怎么将一个Activity封装成对话框的样子-怎样将Activity封装成长按Menu菜单的样子？"><a href="#5-怎么将一个Activity封装成对话框的样子-怎样将Activity封装成长按Menu菜单的样子？" class="headerlink" title="5.怎么将一个Activity封装成对话框的样子? 怎样将Activity封装成长按Menu菜单的样子？"></a>5.怎么将一个Activity封装成对话框的样子? 怎样将Activity封装成长按Menu菜单的样子？</h5><p>简单你只需要设置 一下Activity的主题就可以了在AndroidManifest.xml 中定义 Activity的地方一句话：<br>Xml代码<br>android :theme=”@android:style/Theme.Dialog”<br>android:theme=”@android:style/Theme.Dialog”<br>这就使你的应用程序变成对话框的形式弹出来了，或者<br>Xml代码<br>android:theme=”@android:style/Theme.Translucent”<br>android:theme=”@android:style/Theme.Translucent”<br>就变成半透明的。<br>重写OnCreateOptionMenu方法来处理按下menu后的行为，然后再该方法中弹出对话框形式的Activity。<br>也可以利用事件监听来监听menu按键，并在该按钮按下后弹出对话框形式的Activity。</p>
<h5 id="6-介绍一下Android系统的体系结构"><a href="#6-介绍一下Android系统的体系结构" class="headerlink" title="6.介绍一下Android系统的体系结构"></a>6.介绍一下Android系统的体系结构</h5><p>应用层：android的应用程序通常涉及用户界面和交互。<br>应用框架层：UI组件、各种管理器等。<br>函数库层：系统C库、媒体库、webkit、SQLite等。<br>linux核心库：linux系统运行的组件。</p>
<h5 id="7-描述下横竖屏切换时候-activity-的生命周期"><a href="#7-描述下横竖屏切换时候-activity-的生命周期" class="headerlink" title="7.描述下横竖屏切换时候 activity 的生命周期"></a>7.描述下横竖屏切换时候 activity 的生命周期</h5><p>不设置Activity的android:configChanges时,切屏会重新调用各个生命周期,切横屏时会执行一次,切竖屏时会执行两次.<br>设置Activity的android:configChanges=”orientation”时,切屏还是会重新调用各个生命周期,切横、竖屏时只会执行一次.<br>设置Activity的android:configChanges=”orientation|keyboardHidden”时,切屏不会重新调用各个生命周期,只会执行onConfigurationChanged方法.</p>
<h5 id="8-android-中的动画有哪几种，它们的特点和区别是什么"><a href="#8-android-中的动画有哪几种，它们的特点和区别是什么" class="headerlink" title="8.android 中的动画有哪几种，它们的特点和区别是什么 ?"></a>8.android 中的动画有哪几种，它们的特点和区别是什么 ?</h5><p>两种，一种是补间动画（Tween）动画、还有一种是帧动画（Frame）动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p>
<h5 id="9-一条最长的短信息约占多少-byte"><a href="#9-一条最长的短信息约占多少-byte" class="headerlink" title="9.一条最长的短信息约占多少 byte?"></a>9.一条最长的短信息约占多少 byte?</h5><p>140byte，70个汉字。</p>
<h5 id="10-描述handler-机制的原理"><a href="#10-描述handler-机制的原理" class="headerlink" title="10.描述handler 机制的原理"></a>10.描述handler 机制的原理</h5><p>andriod提供了 Handler 和 Looper 来满足线程间的通信。<br>Handler 先进先出原则。<br>Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。<br>1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。<br>2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。<br>3) Message Queue(消息队列):用来存放线程放入的消息。<br>4)线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。</p>
<h5 id="11-如何将-SQLite-数据库-dictionary-db-文件-与-apk-文件一起发布"><a href="#11-如何将-SQLite-数据库-dictionary-db-文件-与-apk-文件一起发布" class="headerlink" title="11.如何将 SQLite 数据库 (dictionary.db 文件 ) 与 apk 文件一起发布 ?"></a>11.如何将 SQLite 数据库 (dictionary.db 文件 ) 与 apk 文件一起发布 ?</h5><p>可以将dictionary.db文件复制到Eclipse Android工程中的res\raw目录中。所有在res\raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。<br>使用openDatabase方法来打开数据库文件，如果该文件不存在，系统会自动创建/sdcard/dictionary目录，并将res\raw目录中的 dictionary.db文件复制到/sdcard/dictionary目录中</p>
<h5 id="12-说说-android-中-mvc-的具体体现"><a href="#12-说说-android-中-mvc-的具体体现" class="headerlink" title="12.说说 android 中 mvc 的具体体现"></a>12.说说 android 中 mvc 的具体体现</h5><p>mvc是model,view,controller的缩写，mvc包含三个部分：<br>模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。<br>视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。<br>控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。<br>android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：<br>1)视图（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入。<br>2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写过多的代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。<br>3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p>
<h5 id="13-请介绍下-Android-中常用的五种布局"><a href="#13-请介绍下-Android-中常用的五种布局" class="headerlink" title="13.请介绍下 Android 中常用的五种布局"></a>13.请介绍下 Android 中常用的五种布局</h5><p>帧布局（FrameLayout）<br>线性布局(LinearLayout)<br>表格布局(TableLayout)<br>相对布局(RelativeLayout)<br>绝对布局(AbsoluteLayout)</p>
<h5 id="14-如何启用-Service-，如何停用-Service"><a href="#14-如何启用-Service-，如何停用-Service" class="headerlink" title="14.如何启用 Service ，如何停用 Service"></a>14.如何启用 Service ，如何停用 Service</h5><p>1)startService用于启动Service、stopService停止Service。<br>2)bindService绑定Service，unbindService解除Service的绑定。</p>
<h5 id="15-如何优化ListView"><a href="#15-如何优化ListView" class="headerlink" title="15.如何优化ListView"></a>15.如何优化ListView</h5><p>1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。<br>2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。<br>3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。</p>
<h5 id="16-描述4-种-activity-的启动模式"><a href="#16-描述4-种-activity-的启动模式" class="headerlink" title="16.描述4 种 activity 的启动模式"></a>16.描述4 种 activity 的启动模式</h5><p>1)standard ：系统的默认模式，一次跳转即会生成一个新的实例。假设有一个activity命名为MainActivity，执行语句：<br>startActivity(new Intent(MainActivity.this, MainActivity.class))后，MainActivity将跳转到另外一个MainActivity，也就是现在的Task栈里面有MainActivity的两个实例。按返回键后你会发现仍然是在MainActivity（第一个）里面。<br>2)singleTop：singleTop 跟standard 模式比较类似。如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。例：当MainActivity为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。<br>3)singleTask： singleTask模式和后面的singleInstance模式都是只创建一个实例的。在这种模式下，无论跳转的对象是不是位于栈顶的activity，程序都不会生成一个新的实例（当然前提是栈里面已经有这个实例）。这种模式相当有用，在以后的多activity开发中，经常会因为跳转的关系导致同个页面生成多个实例，这个在用户体验上始终有点不好，而如果你将对应的activity声明为 singleTask 模式，这种问题将不复存在。<br>4)singleInstance: 设置为 singleInstance 模式的 activity 将独占一个task（感觉task可以理解为进程），独占一个task的activity与其说是activity，倒不如说是一个应用，这个应用与其他activity是独立的，它有自己的上下文activity。</p>
<h5 id="17-什么是Intent，如何使用？"><a href="#17-什么是Intent，如何使用？" class="headerlink" title="17.什么是Intent，如何使用？"></a>17.什么是Intent，如何使用？</h5><p>Android基本的设计理念是鼓励减少组件间的耦合，因此Android提供了Intent (意图) ，Intent提供了一种通用的消息系统，它允许在你的应用程序与其它的应用程序间传递Intent来执行动作和产生事件。使用Intent可以激活Android应用的三个核心组件：活动、服务和广播接收器。<br>通过startActivity() orstartActivityForResult()启动一个Activity；<br>过 startService() 启动一个服务，或者通过bindService() 和后台服务交互；<br>通过广播方法(比如 sendBroadcast(),sendOrderedBroadcast(),sendStickyBroadcast())发给broadcast receivers</p>
<h5 id="18-Android用的数据库是什么样的？它和sql有什么区别？为什么要用ContentProvide？它和sql的实现上有什么差别？"><a href="#18-Android用的数据库是什么样的？它和sql有什么区别？为什么要用ContentProvide？它和sql的实现上有什么差别？" class="headerlink" title="18.Android用的数据库是什么样的？它和sql有什么区别？为什么要用ContentProvide？它和sql的实现上有什么差别？"></a>18.Android用的数据库是什么样的？它和sql有什么区别？为什么要用ContentProvide？它和sql的实现上有什么差别？</h5><p>Adnroid用的是SQLite数据库。它和其他网络数据库类似，也是通过SQL对数据进行管理。SQLite的操作非常简单，包括数据类型在建表时也可以不指定。<br>使用ContentProvider 可以将数据共享给其他应用，让除本应用之外的应用也可以访问本应用的数据。它的底层是用SQLite 数据库实现的，所以其对数据做的各种操作都是以Sql实现，只是在上层提供的是Uri。</p>
<h5 id="19-通过Intent传递一些二进制数据的方法有哪些"><a href="#19-通过Intent传递一些二进制数据的方法有哪些" class="headerlink" title="19.通过Intent传递一些二进制数据的方法有哪些?"></a>19.通过Intent传递一些二进制数据的方法有哪些?</h5><p>1)使用Serializable接口实现序列化，这是Java常用的方法。<br>2)实现Parcelable接口，这里Android的部分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见的。</p>
<h5 id="20-对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行？"><a href="#20-对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行？" class="headerlink" title="20.对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行？"></a>20.对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行？</h5><p>onResume()恢复数据、onPause()保存数据。</p>
<h5 id="21-如何一次性退出所有打开的Activity"><a href="#21-如何一次性退出所有打开的Activity" class="headerlink" title="21.如何一次性退出所有打开的Activity"></a>21.如何一次性退出所有打开的Activity</h5><p>编写一个Activity作为入口，当需要关闭程序时，可以利用Activity的SingleTop模式跳转该Activity，它上面的所有Activity都会被销毁掉。然后再将该Activity关闭。<br>或者再跳转时，设置intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);这样也能将上面的Activity销毁掉。</p>
<h5 id="22-说说Service的生命周期？"><a href="#22-说说Service的生命周期？" class="headerlink" title="22.说说Service的生命周期？"></a>22.说说Service的生命周期？</h5><p>启动Service的方式有两种，各自的生命周期也有所不同。<br>一、通过startService启动Service：onCreate、onStartCommand、onDestory。<br>二、通过bindService绑定Service：onCreate、onBind、onUnbind、onDestory。</p>
<h5 id="23-什么是AIDL？AIDL是如何工作的？"><a href="#23-什么是AIDL？AIDL是如何工作的？" class="headerlink" title="23.什么是AIDL？AIDL是如何工作的？"></a>23.什么是AIDL？AIDL是如何工作的？</h5><p>AIDL(Android接口描述语言)是一种接口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象。AIDL是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值.。</p>
<h5 id="24-Android如何把文件存放在SDCard上？"><a href="#24-Android如何把文件存放在SDCard上？" class="headerlink" title="24.Android如何把文件存放在SDCard上？"></a>24.Android如何把文件存放在SDCard上？</h5><p>在AndroidManifest.xml中加入访问SDCard的权限如下:<br>&lt;!– 在SDCard中创建与删除文件权限 –&gt;</p>
<p>&lt;!– 往SDCard写入数据权限 –&gt;</p>
<p>要往SDCard存放文件，程序必须先判断手机是否装有SDCard，并且可以进行读写。<br>注意：访问SDCard必须在AndroidManifest.xml中加入访问SDCard的权限。<br>Environment.getExternalStorageState()方法用于获取SDCard的状态，如果手机装有SDCard，并且可以进行读写，那么方法返回的状态等于Environment.MEDIA_MOUNTED。<br>Environment.getExternalStorageDirectory()方法用于获取SDCard的目录。</p>
<h5 id="25-注册广播有几种方式，这些方式有何优缺点？"><a href="#25-注册广播有几种方式，这些方式有何优缺点？" class="headerlink" title="25.注册广播有几种方式，这些方式有何优缺点？"></a>25.注册广播有几种方式，这些方式有何优缺点？</h5><p>两种。一种是通过代码注册，这种方式注册的广播会跟随程序的生命周期。二种是在AndroidManifest.xml中配置广播，这种常驻型广播当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p>
<h5 id="26-什么是ANR-如何避免它"><a href="#26-什么是ANR-如何避免它" class="headerlink" title="26.什么是ANR 如何避免它?"></a>26.什么是ANR 如何避免它?</h5><p>在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR给用户。要避免它，应该尽量少在主线程做耗时太长的操作，应该将这些操作放在线程当中去做。</p>
<h5 id="27-Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗-诺有的话会导致什么问题-如何解决"><a href="#27-Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗-诺有的话会导致什么问题-如何解决" class="headerlink" title="27.Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决?"></a>27.Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决?</h5><p>有可能，比如空指针异常、数组下表越界等异常，这些异常抛出后可能会导致程序FC。在编写代码时应该做好检测，多考虑可能会发生错误的情况，从代码层次解决这些问题。</p>
<h5 id="28-为什么要用-ContentProvider-它和-sql-的实现上有什么差别"><a href="#28-为什么要用-ContentProvider-它和-sql-的实现上有什么差别" class="headerlink" title="28.为什么要用 ContentProvider?它和 sql 的实现上有什么差别?"></a>28.为什么要用 ContentProvider?它和 sql 的实现上有什么差别?</h5><p>使用ContentProvider 可以将数据共享给其他应用，让除本应用之外的应用也可以访问本应用的数据。它的底层是用SQLite 数据库实现的，所以其对数据做的各种操作都是以Sql实现，只是在上层提供的是Uri。</p>
<h5 id="29-谈谈-UI-中-Padding-和-Margin-有什么区别"><a href="#29-谈谈-UI-中-Padding-和-Margin-有什么区别" class="headerlink" title="29.谈谈 UI 中, Padding 和 Margin 有什么区别?"></a>29.谈谈 UI 中, Padding 和 Margin 有什么区别?</h5><p>padding指内边距，表示组件内部元素距离组件边框的距离。<br>marin指外边距，表示组件与组件之间的距离。</p>
<h5 id="30-请介绍下-Android-的数据存储方式。"><a href="#30-请介绍下-Android-的数据存储方式。" class="headerlink" title="30.请介绍下 Android 的数据存储方式。"></a>30.请介绍下 Android 的数据存储方式。</h5><p>Android 提供了5种方式存储数据：<br>1)使用SharedPreferences存储数据；<br>2)文件存储数据；<br>3)SQLite数据库存储数据；<br>4)使用ContentProvider存储数据；<br>5)网络存储数据；</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo NexT主题</title>
    <url>/2022/08/18/Hexo-NexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p><a href="http://theme-next.iissnan.com/theme-settings.html#volunteer-404" target="_blank" rel="noopener">官方文档</a></p>
<h4 id="一、设置文章底部版权信息"><a href="#一、设置文章底部版权信息" class="headerlink" title="一、设置文章底部版权信息"></a>一、设置文章底部版权信息</h4><p>打开主题配置文件<code>_config.yml</code>，找到<code>creative_commons</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true #设置为true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<p><a href="http://creativecommons.org/" target="_blank" rel="noopener">Creative commons协议</a>，这个就是设置版权声明</p>
<a id="more"></a>

<h4 id="二、添加标签页"><a href="#二、添加标签页" class="headerlink" title="二、添加标签页"></a>二、添加标签页</h4><ul>
<li>新建页面：<br>前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags    #新建标签页面</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输入命令后，在<code>根目录/source</code>会生成一个tags文件夹，其中有个index.md文件。</p>
<ul>
<li><p>设置页面类型：<br>修改index.md，添加type：tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2016-11-15 19:10:05</span><br><span class="line">type:  tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置文章的标签：<br>当要为某篇文章添加标签时，只需在文章开头设置相应标签即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: test1    #文章标签</span><br><span class="line">date: 2017-09-20 13:29:11</span><br><span class="line">tags:         #标签</span><br><span class="line">  - test1</span><br><span class="line">  - one</span><br><span class="line">  - two</span><br><span class="line">categories: 测试     #分类</span><br><span class="line">---   </span><br><span class="line">ps：注意这是在新建文章里添加标签</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="三、添加分类、关于页面"><a href="#三、添加分类、关于页面" class="headerlink" title="三、添加分类、关于页面"></a>三、添加分类、关于页面</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories/about</span><br></pre></td></tr></table></figure>

<p>在<code>根目录/source</code>生成文件夹的中修改<code>index.md</code>文件中type类型分别为categories和about即可 </p>
<ul>
<li><p>文章添加分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: test1</span><br><span class="line">date: 2017-09-20 13:29:11</span><br><span class="line">tags:</span><br><span class="line">  - test1</span><br><span class="line">  - one</span><br><span class="line">  - two</span><br><span class="line">categories: 测试     #添加为测试类</span><br><span class="line">---  </span><br><span class="line">ps：注意这是在新建文章里添加分类</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加关于我</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于我</span><br><span class="line">date: 2017-09-17 10:22:54  </span><br><span class="line">type: about </span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line">一只快乐的小菜鸟，欢迎分享知识。</span><br><span class="line">ps：注意这是在about文件夹里修改index.md文件</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="四、添加公益404"><a href="#四、添加公益404" class="headerlink" title="四、添加公益404"></a>四、添加公益404</h4><p>新建 404.html 页面，放到主题的 source 目录下，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot;</span><br><span class="line">          charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot;</span><br><span class="line">          homePageName=&quot;回到我的主页&quot;&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下 <a href="http://www.ixirong.com/404.html" target="_blank" rel="noopener">http://www.ixirong.com/404.html</a></p>
<h4 id="五、添加搜索"><a href="#五、添加搜索" class="headerlink" title="五、添加搜索"></a>五、添加搜索</h4><ul>
<li><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 主题配置文件，启用本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true    #true开启</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="六、添加文章字数统计和阅读时长"><a href="#六、添加文章字数统计和阅读时长" class="headerlink" title="六、添加文章字数统计和阅读时长"></a>六、添加文章字数统计和阅读时长</h4><ul>
<li><p>根目录命令运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>根目录配置文件<code>_config.yml</code>底部添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  #文章内是否显示</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  #网页底部是否显示</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>更多主题配置，点击<a href="https://www.lixint.me/hexo-theme-diy.html" target="_blank" rel="noopener">这里</a><br>博客搭建高级应用，点击<a href="https://blog.annieyu.com/posts/3333782006.html" target="_blank" rel="noopener">这里</a><br>官方主题文档，点击<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">这里</a><br>官方三方服务文档，点击<a href="https://theme-next.org/docs/third-party-services/comments-and-widgets" target="_blank" rel="noopener">这里</a></p>
<p><strong><em>多看官方文档、多看官方文档、多看官方文档</em></strong></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 高级应用</title>
    <url>/2022/08/18/Hexo-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="一、Hexo图片引用"><a href="#一、Hexo图片引用" class="headerlink" title="一、Hexo图片引用"></a>一、Hexo图片引用</h4><ol>
<li><p>本地图片<br>开启<code>_config.yml</code>中的<code>post_asset_folder: true</code> 参数，然后再你的博文生成一个同名的目录，把图片放进去，然后以如下方式引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](博文目录/图片.jpg)</span><br></pre></td></tr></table></figure>

<p> 若不想每次生成一个同名目录，直接在resource目录下添加一个images目录，引用如下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](/博文目录/images/图片.jpg)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用github存储图片<br>github创建一个项目，上传图片，点击图片 -&gt; download，查看路径</p>
</li>
<li><p>使用七牛云<br>点击<a href="https://github.com/gyk001/hexo-qiniu-sync" target="_blank" rel="noopener">这里</a>，查看说明</p>
</li>
</ol>
<a id="more"></a>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 双线部署</title>
    <url>/2022/08/18/Hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="一、coding部署"><a href="#一、coding部署" class="headerlink" title="一、coding部署"></a>一、coding部署</h4><ul>
<li>到<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>注册账号</li>
<li>添加ssh公钥，可参考<a href="https://www.jianshu.com/p/7431fc3e5013" target="_blank" rel="noopener">这篇文章</a></li>
<li>创建项目、仓库名任意，配置pages服务</li>
</ul>
<h4 id="二、github部署"><a href="#二、github部署" class="headerlink" title="二、github部署"></a>二、github部署</h4><ul>
<li>创建仓库，仓库名必须为<code>yourname.github.io</code>，<code>yourname</code>为用户名<br>当你的仓库名为：用户名.github.io 之后默认开启Github Pages</li>
<li>添加ssh key</li>
</ul>
<a id="more"></a>

<h4 id="三、-config-yml修改"><a href="#三、-config-yml修改" class="headerlink" title="三、_config.yml修改"></a>三、_config.yml修改</h4><p>修改<code>站点配置文件</code>的<code>deploy</code>信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">      github: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">      coding: git@git.coding.net:yourname/yourname.git</span><br></pre></td></tr></table></figure>

<h4 id="四、执行部署"><a href="#四、执行部署" class="headerlink" title="四、执行部署"></a>四、执行部署</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Mac adb install apk</title>
    <url>/2019/07/19/Mac-adb-install-apk/</url>
    <content><![CDATA[<h4 id="Mac配置adb"><a href="#Mac配置adb" class="headerlink" title="Mac配置adb"></a>Mac配置adb</h4><ol>
<li>在AS界面上，打开Preferences界面（快捷键： command + , 键），然后复制sdk路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~/Library/Android/sdk/platform-tools</span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p>打开finder，按快捷键：shift + command + g，前往文件夹<br>查看adb文件是否在该目录下</p>
</li>
<li><p>打开终端，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch .bash_profile</span><br><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure>

<p> 修改弹出的.bash_profile的文件，增加以下语句</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:~/Library/Android/sdk/platform-tools</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证：输入adb回车，即可生效</p>
</li>
</ol>
<h4 id="验证adb是否生效"><a href="#验证adb是否生效" class="headerlink" title="验证adb是否生效"></a>验证adb是否生效</h4><p>在终端输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb install apk路径</span><br></pre></td></tr></table></figure>

<p>出现success表示安装成功</p>
<h4 id="常见的Android开发命令"><a href="#常见的Android开发命令" class="headerlink" title="常见的Android开发命令"></a>常见的Android开发命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell：来到手机终端中。</span><br><span class="line">adb divices</span><br><span class="line">adb kill-server</span><br><span class="line">adb start-server</span><br><span class="line">adb install XXX.apk：安装应用程序</span><br><span class="line">abd uninstall （应用程序的包名）</span><br><span class="line">adb -s 设备名字 XXX.apk可以选择哪个模拟器，安装程序</span><br><span class="line">adb pull：（pull拉去，拿取）：把手机中的文件导出去</span><br><span class="line">adb push</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac生成SSH Key</title>
    <url>/2019/07/19/Mac%E7%94%9F%E6%88%90SSH-Key/</url>
    <content><![CDATA[<h4 id="打开vim（terminal-app）查看本地是否存在SSH-Key"><a href="#打开vim（terminal-app）查看本地是否存在SSH-Key" class="headerlink" title="打开vim（terminal.app）查看本地是否存在SSH-Key"></a>打开vim（terminal.app）查看本地是否存在SSH-Key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果vim输出的是如下内容：证明本地没有生成的SSH Key，请执行第二步。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No such file or directory</span><br></pre></td></tr></table></figure>

<p>如果vim输出的是如下内容： 证明本地已经存在SSH Key 文件，请执行第四步。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa    id_rsa.pub</span><br></pre></td></tr></table></figure>

<h4 id="如果没有，生成新的SSH-Key"><a href="#如果没有，生成新的SSH-Key" class="headerlink" title="如果没有，生成新的SSH Key"></a>如果没有，生成新的SSH Key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C&quot;you_email&quot;</span><br></pre></td></tr></table></figure>

<p>your_email：这里填写你在GitLab或者GitHub注册时的邮箱。<br>后面的提示直接敲回车，一路完成。</p>
<h4 id="生成并添加SSH-Key"><a href="#生成并添加SSH-Key" class="headerlink" title="生成并添加SSH Key"></a>生成并添加SSH Key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<h4 id="查看SSH-Key"><a href="#查看SSH-Key" class="headerlink" title="查看SSH Key"></a>查看SSH Key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /Users/xxx/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>xxx是你的电脑用户名，例如：howieMacBook-Pro:~ howie$中的howie关键字。<br>复制生成好的SSH Key 添加到 GitLab 或者GitHub中的SSH Key中即可。</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac使用oh-my-zsh + autosuggestions搭建个性化Terminal</title>
    <url>/2019/10/14/Mac%E4%BD%BF%E7%94%A8oh-my-zsh-autosuggestions%E6%90%AD%E5%BB%BA%E4%B8%AA%E6%80%A7%E5%8C%96Terminal/</url>
    <content><![CDATA[<p>查看Mac上已有的shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>

<p>将默认 shell 改成 zsh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>安装 oh my zsh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>shell solarized 配色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/altercation/solarized.git</span><br><span class="line"># 然后打开 solarized/osx-terminal.app-colors-solarized/Solarized Dark ansi.terminal 配置文件</span><br></pre></td></tr></table></figure>

<p>安装 autojump 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install autojump # 确保有 brew 命令</span><br></pre></td></tr></table></figure>

<p>安装 zsh-autosuggestions 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p>安装 zsh-syntax-highlighting 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>编辑～/.zshrc 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"></span><br><span class="line">ZSH_THEME=&quot;agnoster&quot; # 默认主题主题</span><br><span class="line">plugins=(git brew laravel5 autojump zsh-autosuggestions zsh-syntax-highlighting) # 配置插件</span><br></pre></td></tr></table></figure>

<p>使用如下命令使控制台窗口生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">oh-my-zsh主题选择</a></p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Paging3 LoadStateAdapter显示已加载完所有数据</title>
    <url>/2020/12/29/Paging3-LoadStateAdapter%E6%98%BE%E7%A4%BA%E5%B7%B2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>使用paging3的过程中，本想通过为PagingDataAdaper添加页脚LoadStateAdapter方法onBindViewHolder(holder: LoadStateViewHolder, loadState: LoadState)中的<code>loadState</code>显示<code>loading</code>、<code>error</code>、<code>no more</code>,但是处理no more的时候发现<code>loadState.endOfPaginationReached</code>一直是<code>false</code>，且loadState只有<code>LoadState.Loading</code>、<code>LoadState.Error</code>两种状态</p>
<a id="more"></a>
<h4 id="查看源码："><a href="#查看源码：" class="headerlink" title="查看源码："></a>查看源码：</h4><p>PagingDataAdapter.kt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun withLoadStateFooter(</span><br><span class="line">    footer: LoadStateAdapter&lt;*&gt;</span><br><span class="line">): MergeAdapter &#123;</span><br><span class="line">    addLoadStateListener &#123; loadStates -&gt;</span><br><span class="line">        footer.loadState = loadStates.append</span><br><span class="line">    &#125;</span><br><span class="line">    return MergeAdapter(this, footer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoadStateAdapter.kt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var loadState: LoadState = LoadState.NotLoading(endOfPaginationReached = false)</span><br><span class="line">    set(loadState) &#123;</span><br><span class="line">        if (field != loadState) &#123;</span><br><span class="line">            val oldItem = displayLoadStateAsItem(field)</span><br><span class="line">            val newItem = displayLoadStateAsItem(loadState)</span><br><span class="line"></span><br><span class="line">            if (oldItem &amp;&amp; !newItem) &#123;</span><br><span class="line">                notifyItemRemoved(0)</span><br><span class="line">            &#125; else if (newItem &amp;&amp; !oldItem) &#123;</span><br><span class="line">                notifyItemInserted(0)</span><br><span class="line">            &#125; else if (oldItem &amp;&amp; newItem) &#123;</span><br><span class="line">                notifyItemChanged(0)</span><br><span class="line">            &#125;</span><br><span class="line">            field = loadState</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns true if the LoadState should be displayed as a list item when active.</span><br><span class="line"> *</span><br><span class="line"> * By default, [LoadState.Loading] and [LoadState.Error] present as list items, others do not.</span><br><span class="line"> */</span><br><span class="line">open fun displayLoadStateAsItem(loadState: LoadState): Boolean &#123;</span><br><span class="line">    return loadState is LoadState.Loading || loadState is LoadState.Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看源码可知，只有<code>newItem</code>为<code>true</code>才显示布局UI，若要newItem为true，则loadState的状态只有LoadState.Loading、LoadState.Error，故LoadStateAdapter只有loading、error两个状态。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>监听PagingDataAdapter.addLoadStateListener可知，列表加载到底部会触发loadState.append的<code>NotLoading(endOfPaginationReached=true)</code>状态。</p>
<p>以上，想要通过<code>loadState.endOfPaginationReached</code>属性判断是否到底部，只有拿到loadState的<code>NotLoading</code>状态，通过重写<code>displayLoadStateAsItem</code>方法返回<code>true</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun displayLoadStateAsItem(loadState: LoadState): Boolean &#123;</span><br><span class="line">    return true</span><br><span class="line">//    return loadState is LoadState.Loading || loadState is LoadState.Error || loadState is LoadState.NotLoading</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两种返回值效果一样，loadState的loading、error、notLoading三种状态都会触发。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>paging</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>MPAndroidChart使用</title>
    <url>/2022/08/18/MPAndroidChart%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Y轴-YAxis"><a href="#Y轴-YAxis" class="headerlink" title="Y轴 YAxis"></a>Y轴 YAxis</h4><p>YAxis是AxisBase的子类。YAxis类（在早于2.0.0 版本中叫做YLabels）是数据和一切与垂直轴相关的信息容器。每个Line-，Bar-，Scatter或CandleStickChart都有一个左右YAxis对象，分别负责左轴或右轴。RadarChart只有一个YAxis。默认情况下，图表的两个轴都已启用并将被绘制。</p>
<p>为了获得一个实例中的YAxis类，请调用以下方法之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YAxis leftAxis = chart.getAxisLeft();</span><br><span class="line">YAxis rightAxis = chart.getAxisRight();</span><br><span class="line"></span><br><span class="line">YAxis leftAxis = chart.getAxis(AxisDependency.LEFT);</span><br><span class="line"></span><br><span class="line">YAxis yAxis = radarChart.getYAxis(); // this method radarchart only</span><br></pre></td></tr></table></figure>

<p>在运行时，用public AxisDependency getAxisDependency()确定此轴表示的图表的一侧。</p>
<p>在为图表设置数据之前，需要应用影响轴值范围的自定义。</p>
<a id="more"></a>

<h5 id="轴依赖性"><a href="#轴依赖性" class="headerlink" title="轴依赖性"></a>轴依赖性</h5><p>默认情况下，添加到图表的所有数据都会绘制在图表左侧YAxis。如果未进一步指定和启用，YAxis则调整右侧以表示与左轴相同的比例。</p>
<p>如果您的图表需要支持不同的轴刻度，您可以通过设置应绘制数据的轴来实现。这可以通过更改DataSet对象的AxisDependency来完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LineDataSet dataSet = ...; // get a dataset</span><br><span class="line">dataSet.setAxisDependency(AxisDependency.RIGHT);</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.aliyun.com/article/680371" target="_blank" rel="noopener">设置此项将更改绘制数据的轴。</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Retrofit多图上传</title>
    <url>/2019/07/30/Retrofit%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>首先是定义接口部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MyApi&#123;</span><br><span class="line">    @Multipart</span><br><span class="line">    @POST(&quot;renovation/uploadImg&quot;)</span><br><span class="line">    Observable&lt;HttpResult&gt; upLoadsImg(@PartMap Map&lt;String, RequestBody&gt; params,  @Part(&quot;content&quot;)RequestBody content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> 这里使用<code>@Multipart</code>注解，参数这里使用<code>@PartMap</code>和<code>@Part</code>，他们是用来上传文件用的。 这里需要注意的是，使用了<code>@Multipart</code>注解，参数的类型都应该是<code>RequestBody</code>，不然上传的图片的时候会报<code>JSON must start with an array or an object</code>错误。上传多张图片就使用<code>@PartMap Map&lt;String, RequestBody&gt;</code></p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MyApi&#123;</span><br><span class="line">   @Multipart</span><br><span class="line">   @POST(&quot;renovation/uploadSingleImg&quot;)</span><br><span class="line">   Observable&lt;HttpResult&gt; upLoadsImg(@Part MultipartBody.Part photo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单图上传就用 <code>@Part MultipartBody.Part</code></p>
</blockquote>
<p>其次就是具体实现部分（以多图上传为例）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observer&lt;HttpResult&gt; observer = new Observer&lt;HttpResult&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable e) &#123;</span><br><span class="line">        	progressUtils.dismiss();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(HttpResult httpResult) &#123;</span><br><span class="line">        	//处理返回结果</span><br><span class="line">            if (httpResult.isStatus()) &#123;</span><br><span class="line">                Toast.makeText(mContext, &quot;上传成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                Toast.makeText(mContext, &quot;上传失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            progressUtils.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void submitData() &#123;</span><br><span class="line"></span><br><span class="line">        //图片压缩</span><br><span class="line">        compressUtils();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, RequestBody&gt;  photos = new HashMap&lt;&gt;();</span><br><span class="line">        //mPhotoList是选择图片后的返回路径</span><br><span class="line">        if (mPhotoList.size() &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; mPhotoList.size(); i++) &#123;</span><br><span class="line">                File  file = new File(mPhotoList.get(i).getPhotoPath());</span><br><span class="line">                RequestBody  requestFile = RequestBody.create(MediaType.parse(&quot;multipart/form-data&quot;), file);</span><br><span class="line">                //RequestBody  requestFile = RequestBody.create(MediaType.parse(&quot;image/jpg&quot;), file);</span><br><span class="line"></span><br><span class="line">             	//这里前面一部分是服务器要求你传的key，加上一个i,就可以动态设置key的长度</span><br><span class="line">                photos.put(&quot;AttachmentKey&quot;+i+&quot;\&quot;; filename=\&quot;&quot;+file.getName(),requestFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subscription  = Network.getMyApi().upLoadsImg(photos,RequestBody.create(null,content))</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .unsubscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(observer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里详细解释已经在代码中有注释说明，我按照这个方法上传是没有问题的。相册选机器我推荐使用 <a href="https://github.com/pengjianbo/GalleryFinal" target="_blank" rel="noopener">GalleryFinal</a>里面的功能很详细，实现了拍照、图片选择（单选/多选）、 裁剪（单/多裁剪）、旋转等功能，具体链接里面有介绍。</p>
</blockquote>
<p><strong>MediaType.parse(“multipart/form-data”)传MediaType.parse(“image/jpg”)也可以，原因还不知道。</strong></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>OS X 使用 Hexo 和 Coding Pages 搭建静态博客</title>
    <url>/2022/08/18/OS-X-%E4%BD%BF%E7%94%A8-Hexo-%E5%92%8C-Coding-Pages-%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo</a>是一款基于 Node.js 的静态博客框架, 目前在 GitHub 上已有 9133 star 和 1499 fork。Hexo 生成的静态页面可以部署在 Github 或 Coding 上，并且能够免费绑定自己的域名，可以用来很方便地搭建个人博客。</p>
<hr>
<h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><p>搭建博客需要用到 git，下面这条命令可查看本机是否已安装 git，若未安装可参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">这篇博文</a>进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p>
<p>cURL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>Wget:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure>

<p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><em>以上安装配置如有问题请参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></em></p>
<h4 id="本地建立博客"><a href="#本地建立博客" class="headerlink" title="本地建立博客"></a>本地建立博客</h4><p>安装完成后，新建一个目录如 blog 用于存放博客，切换到该目录下执行以下指令，Hexo 即会在目标文件夹初步生成博客所需要的所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>然后切换到该目录下执行如下命令，安装所需要的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install</span><br></pre></td></tr></table></figure>

<p>生成静态页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>启动本地服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>生成静态页面与启动本地服务可以结合成以下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -g</span><br></pre></td></tr></table></figure>

<p>打开浏览器，输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，看到页面说明hexo环境安装成功。</p>
<h4 id="NexT主题配置"><a href="#NexT主题配置" class="headerlink" title="NexT主题配置"></a>NexT主题配置</h4><ul>
<li><p>安装<br>将它的 Git 仓库 Clone 以后放到博客目录下的 themes 文件夹中即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用<br>与所有Hexo主题一样，把主题源码导入themes目录后，打开<code>根目录配置文件_config.yml</code>， 找到 theme 字段，并将其值更改为 next 就完成了主题的切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="部署到Coding-Pages"><a href="#部署到Coding-Pages" class="headerlink" title="部署到Coding Pages"></a>部署到Coding Pages</h4><p>在 Coding 新建一个项目，假设为 blog，然后修改本地博客目录下的 _config.yml 文件，根据<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">官方文档</a>的描述，修改以下几个参数，这些参数一般在文件底部：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git               #部署方式，这里我们用的是Coding的Git</span><br><span class="line">repo: &lt;repository url&gt;  #仓库地址，例如我的是git@git.coding.net:xxx/blog.git </span><br><span class="line">branch: [branch]        #分支名，可任意填写，我填写的是master</span><br><span class="line">message: [message]      #可不填，这是显示在提交记录里的描述信息，默认为日期</span><br></pre></td></tr></table></figure>

<p>参数修改完成后，我们需要在终端中切换到博客所在目录安装 deploy 组建，执行以下命令将生成的博客静态页面 push 到我们上面在 Coding 创建的 blog 仓库中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后执行依次执行清理命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>生成命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>部署命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>如果在 _config.yml 的 repo 处填写的仓库地址是 https 形式的，在部署时可能需要输入你的 Coding 账号和密码。<br>然后切换到该项目的 Pages 标签，开启 pages 服务，分支名填写为我们在_config.yml 文件中设定的分支，我的是 master。</p>
<h4 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h4><p>pages 服务开启完成后，Coding 会提供一个类似 {user_name}.coding.me/{project_name} 的链接用于访问，例如用户名为 xxx 项目名为 blog 的链接应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://xxx.coding.me/blog</span><br></pre></td></tr></table></figure>

<p><em>若资源加载失败，主题没有显示出来，查看<code>根目录配置文件_config.yml</code></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http://xxx.coding.me/blog/ #项目地址</span><br><span class="line">root: /blog #项目名称</span><br></pre></td></tr></table></figure>

<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>默认提供的链接可能过长或者不便于日常使用，我们也可以绑定自己的域名。首先，需要提前准备一个域名，然后打开自己的域名控制面板，新建一个 CNAME 解析到 {user_name}.coding.me，例如我的是将 <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 解析到 xxx.coding.me；  然后，打开 Coding 项目页面切换到 pages 项，填入刚才的设置解析的域名 <a href="http://www.xxx.com，点击“添加域名绑定”按钮即可，在浏览器中直接访问" target="_blank" rel="noopener">www.xxx.com，点击“添加域名绑定”按钮即可，在浏览器中直接访问</a> <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 就能成功打开。 有时可能由于缓存或者解析时间的问题，稍等片刻即可。</p>
<h4 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page&quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到指定空间</span><br><span class="line">hexo help # 查看帮助</span><br><span class="line">hexo version #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<ul>
<li>使用命令直接创建一篇文章<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;Hello Word&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>成功后我们会在source文件夹下的_posts文件夹中找到我们刚刚创建的文件Hello Word.md，编写格式为markdown, 打开文件即可直接编写</p>
<ul>
<li>手动在_posts文件夹下创建*.md文件的博客，但是我们自己要把头信息给补上。</li>
</ul>
<p><em>部署博客</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>ViewPager2与SwipeRefreshLayout滑动冲突问题的解决</title>
    <url>/2021/04/30/ViewPager2%E4%B8%8ESwipeRefreshLayout%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<blockquote>
<p>我们是在ViewPager2中的Fragment使用了SwipeRefreshLayout。当向下滑动时只要稍微偏左或右都会触发ViewPager2的移动，造成SwipeRefreshLayout卡在页面上不消失。</p>
</blockquote>
<ul>
<li>解决方案一：重写SwipeRefreshLayout</li>
</ul>
<p>我们首先准备修改ViewPager2，可是它没法继承。那么目光只好投向SwipeRefreshLayout。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MySwipeRefreshLayout : SwipeRefreshLayout &#123;</span><br><span class="line">    constructor(context: Context, attes: AttributeSet) : super(context, attes) &#123;&#125;</span><br><span class="line">    constructor(context: Context) : super(context)</span><br><span class="line"></span><br><span class="line">    private var startX = 0</span><br><span class="line">    private var beginScrolll = false //是否开始滑动</span><br><span class="line">    private var startY: Int = 0</span><br><span class="line">    override fun dispatchTouchEvent(ev: MotionEvent): Boolean &#123;</span><br><span class="line">        when (ev.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                startX = ev.x.toInt()</span><br><span class="line">                startY = ev.y.toInt()</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(true)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                val endX = ev.x.toInt()</span><br><span class="line">                val endY = ev.y.toInt()</span><br><span class="line">                val disX = Math.abs(endX - startX)</span><br><span class="line">                val disY: Int = Math.abs(endY - startY)</span><br><span class="line">                if (disX &gt; disY) &#123;</span><br><span class="line">                    if (!beginScrolll)</span><br><span class="line">                        parent.requestDisallowInterceptTouchEvent(false)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    beginScrolll = true</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(true)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(false)</span><br><span class="line">                beginScrolll=false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.dispatchTouchEvent(ev)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案二：使用SmartRefreshLayout替代SwipeRefreshLayout即可。</li>
</ul>
<p><a href="https://blog.csdn.net/qq_15046309/article/details/106005736" target="_blank" rel="noopener">参考原文地址</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh: command not found: hexo</title>
    <url>/2022/08/18/zsh-command-not-found-hexo/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>最近打算在hexo新建一篇文章，执行终端时:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zsh: command not found: hexo</span><br></pre></td></tr></table></figure>

<h4 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h4><p>可能是前段时间学习vue的时候，重新安装了node，导致PATH路径<code>/usr/local/lib/node_modules/</code>目录下的<code>hexo-cli</code>丢失。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>通过 –prefix 参数指定链接创建的目标路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global remove hexo-cli</span><br><span class="line"></span><br><span class="line"># 重新安装</span><br><span class="line">yarn global add hexo-cli --prefix /usr/local</span><br></pre></td></tr></table></figure>

<p><a href="https://www.dazhuanlan.com/maple0015/topics/1070884" target="_blank" rel="noopener">重新执行hexo，成功。</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/07/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>oh-my-zsh ，zsh: command not found: adb</title>
    <url>/2019/12/26/oh-my-zsh-%EF%BC%8Czsh-command-not-found-adb/</url>
    <content><![CDATA[<p>安装完zsh，在使用相关shell命令，出现了”zsh: command not found adb:adb”,”zsh: command not found: git” 等一系列error</p>
<blockquote>
<p>其实就是bash shell 以及zsh shell 是两种读取系统环境变量（使用adb的前提是你肯定已经在bash的 .bash_profile 已经配置相关android tool的环境变量了，从而才能使用adb命令）<br>然而在使用zsh shell的时候，你并没有把相关的环境变量的配置设置到 .zshrc 中（功能上类似bash 的.bash_profile）</p>
</blockquote>
<a id="more"></a>

<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>既然是.zshrc 没有配置相关环境变量设置，把 bash 中.bash_profile 全部环境变量加入就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open .zshrc</span><br></pre></td></tr></table></figure>

<p>然后找到# User configuration部分，添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source .zshrc</span><br></pre></td></tr></table></figure>

<p>最后再运行adb命令即可</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>时光很长 莫要慌张</title>
    <url>/2019/07/23/%E6%97%B6%E5%85%89%E5%BE%88%E9%95%BF-%E8%8E%AB%E8%A6%81%E6%85%8C%E5%BC%A0/</url>
    <content><![CDATA[<blockquote>
<p>未曾开言我先笑场，笑场完了听我诉一诉衷肠。        –《笑场》</p>
</blockquote>
<p>近来，年岁愈涨，愈感到焦虑，总想一下子把所有的事情做完。都说，人生最好的际遇，就是在适合的年纪做适合的事。年少时，好好学习；成年后，结婚生子。</p>
<a id="more"></a>

<p>刚毕业，总是心高气傲，想着做一个优秀的工程师、找一个可以红袖添香、慢慢变老的人。理想很丰满、现实很骨感。这句话真的很现实。</p>
<p>时光如白驹过隙，转瞬而逝，never say goodbye to u。</p>
<p>或许到了年纪，工作上不顺心，想转型却又难找到机会，父母也催促着你成家。瞬间，感觉自己过了年纪，该做的事什么都没有做，既没有遇到合适的人、自己也没有成长成自己期望的样子。于是，一事无成。开始迷茫和焦虑，想赶紧把该做的事情都做了，找个人结婚、生子、平平凡凡、庸庸碌碌就好。再难以静下心来，去学习和充实，总是找些喜剧以自娱，甚至开始二倍速看世界。既想改变，又在不停的浪费时间，兜兜转转，还在原地。</p>
<p>《笑场》序言，李诞说过一句话：</p>
<blockquote>
<p>我一直以来是个沮丧的人，认为人生没有丝毫意义，梦幻泡影。<br>近来因机缘获得一点儿开悟，找到了活下去的理由——人生确实没有意义，但人生有美。<br>梦幻泡影嘛，本来就是美的。</p>
</blockquote>
<p>我想说的是，时光还很长，不必焦虑。不妨出去走走看看，世间的繁华，热闹之后，总会归于平静。给自己点时间，找回本心。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>常用正则表达式</title>
    <url>/2021/06/10/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="java正则表达式常用字符说明"><a href="#java正则表达式常用字符说明" class="headerlink" title="java正则表达式常用字符说明"></a>java正则表达式常用字符说明</h5><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\”匹配”\”，”(“匹配”(“。</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="center">n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="center">n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="center">匹配 pattern 并捕获该匹配的子表达式。可以使用 0…9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)”。</td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="center">匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (</td>
</tr>
<tr>
<td align="center">(?=pattern)</td>
<td align="center">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="center">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">y</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="center">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="center">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="center">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="center">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="center">匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">非数字字符匹配。等效于 [^0-9]。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="center">\xn</td>
<td align="center">匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td align="center">\num</td>
<td align="center">匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</td>
</tr>
<tr>
<td align="center">\nm</td>
<td align="center">标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td align="center">\nml</td>
<td align="center">当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</td>
</tr>
<tr>
<td align="center">\un</td>
<td align="center">匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody></table>
<p>以上内容来自<a href="https://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">runoob</a></p>
<a id="more"></a>

<h5 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h5><h6 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h6><ol>
<li>汉字：^[\u4e00-\u9fa5]{0,}$</li>
<li>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</li>
<li>长度为3-20的所有字符：^.{3,20}$</li>
<li>由26个英文字母组成的字符串：^[A-Za-z]+$</li>
<li>由26个大写英文字母组成的字符串：^[A-Z]+$</li>
<li>由26个小写英文字母组成的字符串：^[a-z]+$</li>
<li>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</li>
<li>由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$</li>
<li>中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</li>
<li>中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</li>
<li>可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\x22]+</li>
<li>禁止输入含有<del>的字符：[^</del>\x22]+</li>
</ol>
<h6 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h6><ol>
<li>汉字：^[\u4e00-\u9fa5]{0,}$</li>
<li>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</li>
<li>长度为3-20的所有字符：^.{3,20}$</li>
<li>由26个英文字母组成的字符串：^[A-Za-z]+$</li>
<li>由26个大写英文字母组成的字符串：^[A-Z]+$</li>
<li>由26个小写英文字母组成的字符串：^[a-z]+$</li>
<li>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</li>
<li>由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$</li>
<li>中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</li>
<li>中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</li>
<li>可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\x22]+</li>
<li>禁止输入含有<del>的字符：[^</del>\x22]+</li>
</ol>
<h6 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h6><ol>
<li>Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em>$</li>
<li>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</li>
<li>InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</li>
<li>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</li>
<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ </li>
<li>国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}</li>
<li>身份证号(15位、18位数字)：^\d{15}|\d{18}$</li>
<li>短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</li>
<li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</li>
<li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</li>
<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$  </li>
<li>日期格式：^\d{4}-\d{1,2}-\d{1,2}</li>
<li>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</li>
<li>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ </li>
<li>钱的输入格式：<ol>
<li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ </li>
<li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ </li>
<li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ </li>
<li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ </li>
<li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ </li>
<li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ </li>
<li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ </li>
<li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ </li>
<li>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li>
</ol>
</li>
<li>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</li>
<li>中文字符的正则表达式：[\u4e00-\u9fa5]</li>
<li>双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li>
<li>空白行的正则表达式：\n\s*\r    (可以用来删除空白行)</li>
<li>HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/\1&gt;|&lt;.</em>? /&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li>
<li>首尾空白字符的正则表达式：^\s<em>|\s</em>$或(^\s<em>)|(\s</em>$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>
<li>腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)</li>
<li>中国邮政编码：[1-9]\d{5}(?!\d)    (中国邮政编码为6位数字)</li>
<li>IP地址：\d+.\d+.\d+.\d+    (提取IP地址时有用)</li>
<li>IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))    (由@飞龙三少 提供,感谢共享)</li>
</ol>
<p>详情参考<a href="https://blog.csdn.net/gdutxiaoxu/article/details/77800756" target="_blank" rel="noopener">这篇</a>文章</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
</search>
